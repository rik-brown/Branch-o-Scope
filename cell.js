// cell Class
function Cell(pos, vel, cellStartSize_, lifespan_) {

  // BOOLEAN
  this.growing = true; // A new cell always starts of moving & growing

  // GROWTH & REPRODUCTION
  this.age = 0;
  this.growth = p.growth * 0.01; //Growth Factor is determined by GUI & is equal for all cells
  //this.lifespan = lifespan_ * random (0.8, 1.2);
  this.lifespan = lifespan_ + 1;
  this.life = this.lifespan;


  // SIZE AND SHAPE
  this.cellStartSize = cellStartSize_;
  this.cellEndSize = 0.5;
  this.r = this.cellStartSize; // Initial value for radius
  this.size = map(this.r, this.cellStartSize, this.cellEndSize, 1, 0); // Size is a measure of progress from starting to final radius
  //this.flatness = random (0.6, 1.4); // Flatness makes the circle into an ellipse
  this.flatness = 1;
  //this.growth = (this.cellStartSize-this.cellEndSize)/this.lifespan; // Growth-rate is calculated from size & expected lifespan


  // MOVEMENT
  this.position = pos.copy(); //cell has position
  this.velocityLinear = vel.copy(); //cell has velocity
  this.noisePercent = p.noisePercent;
  this.spiral = p.spiral;
  this.vMax = random(0,4); //Maximum magnitude in velocity components generated by noise
  this.xoff = random(1000); //Seed for noise
  this.yoff = random(1000); //Seed for noise
  this.step = random(0.001, 0.006); //Step-size for noise

  this.run = function() {
    this.live(); // Cell matures (may be useful later for colorshifting)
    this.updatePosition();
    this.updateSize();
  }

  this.live = function() {
    this.age += 1; // Age starts at 0 and increases by one for every drawcycle
    this.maturity = map(this.age, 0, this.lifespan, 1, 0); // Maturity moves from 1 at spawn to 0 at death
  }

  this.updatePosition = function() {
    var vx = map(noise(this.xoff), 0, 1, -this.vMax, this.vMax); // get new vx value from Perlin noise function
    var vy = map(noise(this.yoff), 0, 1, -this.vMax, this.vMax); // get new vy value from Perlin noise function
    var velocityNoise = createVector(vx, vy); // create new velocity vector based on new vx, vy components
    this.xoff += this.step; // increment x offset for next vx value
    this.yoff += this.step; // increment x offset for next vy value
    this.velocity = p5.Vector.lerp(this.velocityLinear, velocityNoise, p.noisePercent*0.01);
    var screwAngle = map(this.maturity, 0, 1, 0, this.spiral * TWO_PI); //swapped size with maturity
    this.velocity.rotate(screwAngle);
    this.position.add(this.velocity);
  }

  this.updateSize = function() {
    this.r += this.growth;
    this.size = map(this.r, this.cellStartSize, this.cellEndSize, 1, 0);
  }

  this.timeToDivide = function() {
    this.life--;
    if (this.life < 0 && this.growing) { // when life has counted down to zero, the cell will divide
      this.growing = false;
      return true;
    } else {
      return false;
    }
  }

  this.spawn = function(angle) {
    // What is my current heading
    var theta = this.velocity.heading();
    // What is my current speed
    var m = this.velocity.mag();
    // Turn me
    theta += radians(angle);
    // Look, polar coordinates to cartesian!!
    var newvel = createVector(m * cos(theta), m * sin(theta));
    // Return a new Branch
    return new Cell(this.position, newvel, this.r, this.lifespan * 0.8);
  }


  // Display the cell using ellipse
  this.displayEllipse = function() {
    stroke(255, 40);
    fill(0);
    var angle = this.velocity.heading();
    push();
    translate(this.position.x, this.position.y);
    rotate(angle);
    ellipse(0, 0, this.r, this.r * this.flatness); // Red ellipse at full size of cell
    pop();
  }


  // Display the cell using points
  this.displayPoint = function() {
    noFill();
    strokeWeight(1);
    stroke(255);
    point(this.position.x, this.position.y);
  }

  // Death
  this.dead = function() {
    if (this.r < 0 || this.r > this.cellStartize * 4) {print('Death by size'); return true;} // Death by size
    if (this.maturity = 0) {print('Death by old age');return true;} // Death by old age (regardless of size, which may remain constant)
    if (this.position.x > width + this.r*this.flatness || this.position.x < -this.r*this.flatness || this.position.y > height + this.r*this.flatness || this.position.y < -this.r*this.flatness) {return true;} // Death if move beyond canvas boundary
    else {return false; }
  }


}
